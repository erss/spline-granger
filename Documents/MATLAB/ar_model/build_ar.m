function [ adj_mat] = build_ar( data, nlags )
% BUILD_AR builds network model from MVAR modeling
%
% INPUTS:
%  data           = A matrix of electode data with dimensions electrodes x
%                  time
%  nlags          = The number of lags used as used for predictor variables
% 
% OUTPUTS:
%  adj_mat = adjacencey matrix for corresponding network

    nobservations = length(data(1,nlags+1:end)); %  the number of 
                                                 % observations used for response variables


    % Initialize outputs
    nelectrodes = size(data,1);
    C = cell(1,nelectrodes);        %  cell containing model fit for each electrode
    adj_mat = zeros(nelectrodes);  
    F = zeros(nelectrodes);         %  matrix of F statistics generated by removing subset of
                                    %       predictor variables
    

    % Build history matrix
X = []; 

% Vector of electrode names corresponding to order in build matrix
% e.g. for trivariate case with two lags, [1 1 2 2 3 3]
e_names = zeros(1,nlags*nelectrodes); 
j = 1;
for k = 1:nelectrodes
    X_temp = []; 
    sgnl = data(k,:)';
    for i=1:nlags                                   %For each lag,
        X_temp = [X_temp, circshift(sgnl,i)];   %... shift x and store it.
        e_names(j) = k;
        j = j+ 1;
    end
    X_temp = X_temp(nlags+1:end,:);  
    X = [X X_temp];
end
% 
%     % Vector of electrode names corresponding to order in build matrix
%     % e.g. for trivariate case with two lags, [1 1 2 2 3 3]
%     e_names = zeros(1,nlags*nelectrodes); 
%     i = 1;
%     for k = 1:nelectrodes
%         for j = 1:nlags
%             e_names(i) = k;
%             i = i+ 1;
%         end;
%     end

    % Build models and test correlation for every electrode pair
    for electrode = 1:nelectrodes
        
%         % Generate observations for given y
%         x = data(electrode,:);
%         y = [];
%         for i = 1:nobservations
%             y = [y x(t0+i-1)];
%         end
%         y = y';
   
         % Generate observations for given y
        x = data(electrode,:);
        y = x(nlags+1:end);   
        y = y';

        % Fit full model
        [b,~,stats] = glmfit(X,y);
        fit.weights = b;
        fit.pvals = stats.p;
        fit.se = stats.se;
        C{electrode} = fit;

     
        % Calculate RSS for full model
        A =[ones(size(X,1),1) X];
        y_hat = A*round(b,10) ;
     %   y_hat = A*b ;
        error = (y_hat - y).^2;
        rss = sum(error);
  %      error = exp((y_hat - y).^2);
  %      rss = prod(error);
       
        % Fit partial model and calculate RSS0 for all minus subset
        for ii = 1:nelectrodes
          indices = ~(e_names == ii); % returns logical vector
          X0 = X(:,indices);
          [b0,~,stats] = glmfit(X0,y);
          fit0.weights = b;
          fit0.pvals = stats.p;
          fit0.se = stats.se;

          A =[ones(size(X0,1),1) X0];
          y_hat = A*round(b0,10) ;
         % y_hat = A*b0 ;
          error = (y_hat - y).^2;
          rss0 = sum(error);
      %    error = exp((y_hat - y).^2);
      %    rss0 = prod(error);
          
          % Compute F statistic
          F(electrode,ii) = ((rss0 - rss)/nlags)/(rss/(nobservations-nelectrodes*nlags-1));
           
          
        end
        
    end
 
    
    % Hypothesis test
    
    
    adj_mat = fpdf(F,nlags,nobservations-nelectrodes*nlags-1);
    
    
    q = 0.01; % max number acceptable proportion of false discoveries 
    m = nelectrodes^2; % number of total tests performed
    
    ivals = 1:m;
    s = ivals*q/m;
    [pvals, index] = sort(adj_mat(:));
    R = find(s>pvals'); % indices to reject null
    
    adj_mat = zeros(nelectrodes);
    adj_mat(index(R)) = 1; % reject H0 -> correlation
         
    
end

